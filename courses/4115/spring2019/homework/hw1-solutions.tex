\documentclass[twocolumn]{article}
\usepackage[T1]{fontenc}
\usepackage{times}
\usepackage{listings}
\usepackage[scaled=0.88]{luximono}

\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\title{COMS W4115 Programming Languages and Translators \\
Homework Assignment 1 Solutions}
\author{Prof. Stephen A. Edwards}
\date{}

\pagestyle{empty}

\lstset{language=[Objective]caml,
  basicstyle=\ttfamily,
  identifierstyle={\itshape},
  showstringspaces=false,
}

\topmargin      -24.0mm
\oddsidemargin  -11.0mm
\evensidemargin -11.0mm
\textheight     243.5mm
\advance\textheight-\baselineskip
\textwidth      183.0mm
\columnsep        4.1mm
\parindent        1.0em
\headsep          6.3mm
\headheight        12pt
\lineskip           1pt
\normallineskip     1pt

\begin{document}
\maketitle
\thispagestyle{empty}

\begin{enumerate}

\item

  My preferred solution first generates a list consisting of the
  length of each run, then returns the maximum element in that list.
  
\begin{lstlisting}
let maxrun l =
  let rec runs n = function
    [] -> []
  | h :: (s::_ as t) when h = s ->
                       runs (n+1) t
  | h :: t -> (n+1) :: runs 0     t
  in List.fold_left max 0 (runs 0 l)
\end{lstlisting}

Another solution is to pass along a running maximum (the \textit{m}
argument), although I think this gives an undesirable blending of
operations.

\begin{lstlisting}
let maxrun l =
  let rec runs m r = function
      [] -> m
    | h::(s::_ as t) when h = s ->
              runs m             (r+1) t
    | h::t -> runs (max m (r+1)) 0     t
  in runs 0 0 l
\end{lstlisting}


\newpage
\item

\begin{lstlisting}[morekeywords={rule,parse,eof}]
{ type token = EOF | Word of string }

rule token = parse
  | eof { EOF }
  | ['a'-'z' 'A'-'Z']+ as word { Word(word) }
  | _ { token lexbuf }

{
module StringMap = Map.Make(String);;

 let lexbuf = Lexing.from_channel stdin in
 let wordlist = 
   let rec next l =
     match token lexbuf with
       EOF     -> l
     | Word(s) -> next (s :: l)
   in next []
 in
 
 let map =
   List.fold_left
     (fun map word ->
       StringMap.add word
         (if StringMap.mem word map then
           1 + StringMap.find word map
         else 1
         ) map
     ) StringMap.empty wordlist
 in

 let wordcounts =
   StringMap.fold
    (fun word count l -> (count, word) :: l)
    map [] in

 let wordcounts =
   List.sort (fun (c1, _) (c2, _) ->
              Pervasives.compare c2 c1) wordcounts
 in List.iter
     (fun (c, w) ->
      print_endline (string_of_int c ^ " " ^ w))
     wordcounts
}
\end{lstlisting}

\newpage

\item

\begin{lstlisting}[language={},
morekeywords={open,rule,parse,as,eof}]
{ open Parser }

rule token = parse
  [' ' '\t' '\r' '\n'] { token lexbuf }
| '+' { PLUS }
| '-' { MINUS }
| '*' { TIMES }
| '/' { DIVIDE }
| '=' { ASSIGN }
| ';' { SEMI }
| ['0'-'9']+ as lit { LITERAL(int_of_string lit) }
| ['a'-'z']+ as id { VARIABLE(id) }
| eof { EOF }
\end{lstlisting}

\hrule

\begin{lstlisting}[language={},
morekeywords={open,token,left,right,start,type,of,int}]
%{ open Ast %}

%token PLUS MINUS TIMES DIVIDE EOF
%token ASSIGN SEMI
%token <int> LITERAL
%token <string> VARIABLE

%left SEMI
%right ASSIGN
%left PLUS MINUS
%left TIMES DIVIDE

%start expr
%type <Ast.expr> expr

%%

expr:
  expr PLUS   expr    { Binop($1, Add, $3) }
| expr MINUS  expr    { Binop($1, Sub, $3) }
| expr TIMES  expr    { Binop($1, Mul, $3) }
| expr DIVIDE expr    { Binop($1, Div, $3) }
| expr SEMI  expr     { Seq($1, $3) }
| VARIABLE ASSIGN expr { Asn($1, $3) }
| LITERAL             { Lit($1) }
| VARIABLE            { Var($1) }
\end{lstlisting}

\hrule

\begin{lstlisting}
type operator = Add | Sub | Mul | Div

type expr =
    Binop of expr * operator * expr
  | Seq of expr * expr
  | Asn of string * expr
  | Var of string
  | Lit of int
\end{lstlisting}

\newpage

Note how the environment \emph{env} is threaded through every call to
\emph{eval}, including binary operators.

\begin{lstlisting}
open Ast

module StringMap = Map.Make(String)  

let rec eval env = function 
    Lit(x)      -> (x, env)
  | Var(x)      -> (StringMap.find x env, env)
  | Seq(e1, e2) -> let (_,env) = eval env e1 in
                   eval env e2
  | Asn(v, e)   -> let (vv, env) = eval env e in
                   (vv, StringMap.add v vv env)
  | Binop(e1, op, e2) ->
      let (v1, env) = eval env e1 in
      let (v2, env) = eval env e2 in
      ((match op with
	Add -> v1 + v2
      | Sub -> v1 - v2
      | Mul -> v1 * v2
      | Div -> v1 / v2), env)

let _ =
  let lexbuf = Lexing.from_channel stdin in
  let expr = Parser.expr Scanner.token lexbuf in
  let (result, _) = eval StringMap.empty expr in
  print_endline (string_of_int result)
\end{lstlisting}

\end{enumerate}

\end{document}

% Local Variables:
% compile-command: "make hw1-solutions.pdf"
% End:
