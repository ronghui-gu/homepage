\documentclass[twocolumn,letterpaper]{article}
\usepackage{fourier}
\usepackage[T1]{fontenc}
\usepackage[scaled=0.88]{luximono}

\usepackage[top=24mm,left=11mm,right=11mm,bottom=24mm]{geometry}

% Make | a mathrel symbol: improves alternation (a | b) spacing
\mathcode`\|="326A

\frenchspacing

\title{COMS W4115 \\
Programming Languages and Translators \\
Homework Assignment 2}
\author{
\begin{tabular}{ll}
Prof. Stephen A. Edwards &    Due Oct 11, 2018 \\
Columbia University & at 11:59PM PM \\
\end{tabular}
}
\date{}

\begin{document}
\maketitle

Submit your assignment as a single PDF file on Courseworks.

Do this assignment alone.  You may consult the instructor or a TA,
but not other students.  You may not consult solutions from earlier semesters.

\begin{enumerate}

\item Write a regular expression for floating constants according
  to the following (after K\&R):

\begin{quote}
A floating constant consists of an integer part, a decimal point, a
fraction part, an \texttt{e} or an \texttt{E}, and an optionally
signed integer exponent. The integer and fraction parts both consist
of a sequence of digits. Either the integer part, or the fraction part
(not both) may be missing; either the decimal point or the
\texttt{e}/\texttt{E} and the exponent (not both) may be missing.
\end{quote}

Hint: make sure your regular expression accepts floating constants
such as \verb|1. 0.5e-15 .3E+3 .2 1e5 3.5E-4| but not integer
constants such as \verb|42|

%% 1a)
%%
%%   '.' [0-9]+ Exp?
%% | [0-9]+ ( '.' [0-9]* Exp?
%%          | Exp)
%%
%% Exp: ('e'|'E') ('+'|'-')? [0-9]+

\item Draw a DFA for a scanner that recognizes and distinguishes the
  following set of keywords.  Draw accepting states with double lines
  and label them with the name of the keyword they accept.  Follow the
  definition of a DFA given in class.

\noindent

\texttt{deinit fileprivate func open operator private if init self Self Any as}

%%
%% 1b)
%%
%% Must be a tree, don't do anything more
%%

\item Construct nondeterministic finite automata for the following
  regular expressions using Thompson's algorithm (Algorithm 3.23,
  p.\ 159, also shown in class), then use the subset construction
  algorithm to construct DFAs for them using Algorithm 3.20 (p.\ 153,
  also shown in class).

\begin{enumerate}
\item $a\ (a^* | b^*)\ a$
\item $(ba | ab)^* b$
\item $(a\ (b | \epsilon)\ b)^*$
\end{enumerate}

Number the NFA states; use the numbers to label DFA states while
performing subset construction, e.g., like Figure 3.35 (p.\ 155).

\if 0
http://jsmachines.sourceforge.net/machines/slr.html

E' -> E
E -> a F b
E -> c
F -> E a F
F -> E


Trace	Tree
Step	Stack			Input		Action
1	0			a a c a c b b $	s2	
2	0 a 2			a c a c b b $	s2
3	0 a 2 a 2		c a c b b $	s3
4	0 a 2 a 2 c 3		a c b b $	r2
5	0 a 2 a 2 E		a c b b $	5
6	0 a 2 a 2 E 5		a c b b $	s7
7	0 a 2 a 2 E 5 a 7	c b b $		s3
8	0 a 2 a 2 E 5 a 7 c 3	b b $		r2
9	0 a 2 a 2 E 5 a 7 E	b b $		5
10	0 a 2 a 2 E 5 a 7 E 5	b b $		r4
11	0 a 2 a 2 E 5 a 7 F	b b $		8
12	0 a 2 a 2 E 5 a 7 F 8	b b $		r3
13	0 a 2 a 2 F		b b $		4
14	0 a 2 a 2 F 4		b b $		s6
15	0 a 2 a 2 F 4 b 6	b $		r1
16	0 a 2 E			b $		5
17	0 a 2 E 5		b $		r4
18	0 a 2 F			b $		4
19	0 a 2 F 4		b $		s6
20	0 a 2 F 4 b 6		$		r1
21	0 E			$		1
22	0 E 1			$		acc
\fi

\item Using this grammar, whose three terminals are $a$, $b$, and $c$,
%%
\[\begin{array}{l}
E \rightarrow a\ F\ b \\
E \rightarrow c \\
F \rightarrow E\ a\ F \\
F \rightarrow E \\
 \end{array}\]

\begin{enumerate}

\item Construct a rightmost derivation for $a a c a c b b$ and
  show the handle of each right-sentential form.

\item Show the steps of a shift-reduce (bottom-up) parser
  corresponding to this rightmost derivation.

\item Show the concrete parse tree that would be constructed during
  this shift-reduce parse.

\end{enumerate}



\item Build the LR(0) automaton for the following ambiguous grammar.
  \textbf{if}, \textbf{else}, and \textbf{null} are terminals; the
  third rule indicates $T$ may be the empty string.  Indicate the state
  in which the shift/reduce conflict appears.

\[
\begin{array}{l}
S' \rightarrow S \\
S \rightarrow \textbf{if}\ S\ T \\
S \rightarrow \textbf{null} \\
T \rightarrow \\
T \rightarrow \textbf{else}\ S
\end{array}
\]

Check your work by running ``ocamlyacc -v'' on the grammar below and
looking through the ``.output'' file.  Include annotated snippets from
the .output file that confirm your answer.

\begin{verbatim}
%token IF ELSE NULL
%start s
%type <int>s

%%

s : IF s t      { 0 }
  | NULL        { 0 }

t : /* empty */ { 0 }
  | ELSE s      { 0 }
\end{verbatim}

% Problem comes after IF s:
%
% State is
%
% s -> IF s . t
% t -> .
% t -> . ELSE s
%
% Shift on ELSE or reduce t -> epsilon?
% Problem is that ``ELSE'' is in the follow set of t.

\if 0
   0  $accept : %entry% $end

   1  s : IF s t
   2    | NULL

   3  t :
   4    | ELSE s

   5  %entry% : '\001' s

state 0
	$accept : . %entry% $end  (0)

	'\001'  shift 1
	.  error

	%entry%  goto 2


state 1
	%entry% : '\001' . s  (5)

	IF  shift 3
	NULL  shift 4
	.  error

	s  goto 5


state 2
	$accept : %entry% . $end  (0)

	$end  accept


state 3
	s : IF . s t  (1)

	IF  shift 3
	NULL  shift 4
	.  error

	s  goto 6


state 4
	s : NULL .  (2)

	.  reduce 2


state 5
	%entry% : '\001' s .  (5)

	.  reduce 5


6: shift/reduce conflict (shift 7, reduce 3) on ELSE
state 6
	s : IF s . t  (1)
	t : .  (3)

	ELSE  shift 7
	$end  reduce 3

	t  goto 8


state 7
	t : ELSE . s  (4)

	IF  shift 3
	NULL  shift 4
	.  error

	s  goto 9


state 8
	s : IF s t .  (1)

	.  reduce 1


state 9
	t : ELSE s .  (4)

	.  reduce 4


State 6 contains 1 shift/reduce conflict.


6 terminals, 4 nonterminals
6 grammar rules, 10 states
\fi



\end{enumerate}
\thispagestyle{empty}
\end{document}

% Local Variables:
% compile-command: "make hw2.pdf"
% End:
